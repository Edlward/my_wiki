<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>驱动第三天---总线 # - jackeyt wiki</title>
        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <script src="../js/jquery-1.10.2.min.js" defer></script>
        <script src="../js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="..">jackeyt wiki</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li >
                                <a href="..">Welcome to MkDocs</a>
                            </li>
                            <li >
                                <a href="../ARMLinux设备树/">ARMLinux设备树</a>
                            </li>
                            <li >
                                <a href="../SUMMARY/">SUMMARY</a>
                            </li>
                            <li >
                                <a href="../[史上最详细]VSCode搭建ARMLinuxMakefile工程IDE（C-C++）/">VS Code搭建ARM Linux Makefile工程IDE（C/C++）[史上最详细]</a>
                            </li>
                            <li >
                                <a href="../三种总线的横向对比表/">三种总线的横向对比表</a>
                            </li>
                            <li >
                                <a href="../手把手教你从单片机移植驱动到ARMLinux上/">手把手教你从单片机移植驱动到ARMLinux上</a>
                            </li>
                            <li >
                                <a href="../驱动第一天---驱动基础/">驱动第一天---驱动基础 #</a>
                            </li>
                            <li class="active">
                                <a href="./">驱动第三天---总线 #</a>
                            </li>
                            <li >
                                <a href="../驱动第二天---中断/">驱动第二天---中断 #</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li >
                                <a rel="next" href="../驱动第一天---驱动基础/">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li >
                                <a rel="prev" href="../驱动第二天---中断/">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#-">驱动第三天---总线</a></li>
            <li><a href="#1">1. 总线的基本概念</a></li>
            <li><a href="#2-sysfs">2. Sysfs文件系统</a></li>
            <li><a href="#3">3. 写一个自己的总线驱动</a></li>
            <li><a href="#4-platform">4. 平台总线(platform)的基本概念</a></li>
            <li><a href="#5-platform">5. 平台总线(platform)编程接口</a></li>
            <li><a href="#5-platform-led">5. 写一个platform led驱动</a></li>
        <li class="main "><a href="#iic">IIC总线驱动</a></li>
            <li><a href="#1-i2c">1 i2c协议和时序</a></li>
            <li><a href="#2-i2c">2 i2c子系统软件框架 ##</a></li>
            <li><a href="#3-i2c">3  I2c子系统中涉及到的设备树文件：</a></li>
            <li><a href="#4-i2c-driver">4  i2c driver驱动的编写</a></li>
            <li><a href="#4">4 陀螺仪和加速度工作原理，它们的应用</a></li>
            <li><a href="#41">4.1  硬件接线图</a></li>
            <li><a href="#42">4.2  陀螺仪和加速度工作原理及应用</a></li>
            <li><a href="#5-mpu605">5 mpu605   常用寄存器</a></li>
            <li><a href="#6-iicapis">6 iic驱动发送指令APIs</a></li>
            <li><a href="#7-ioctl">7 ioctl:　给驱动发送不同指令</a></li>
            <li><a href="#8-mpu6050">8 mpu6050的数据</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="-">驱动第三天---总线</h1>
<div class="toc">
<ul>
<li><a href="#-">驱动第三天---总线</a><ul>
<li><a href="#1">1. 总线的基本概念</a></li>
<li><a href="#2-sysfs">2. Sysfs文件系统</a></li>
<li><a href="#3">3. 写一个自己的总线驱动</a><ul>
<li><a href="#31-bus">3.1 写一个自己的总线驱动——bus</a></li>
<li><a href="#32-driver">3.2 写一个自己的总线驱动——driver</a></li>
<li><a href="#33-device">3.3 写一个自己的总线驱动——device</a></li>
<li><a href="#34">3.4 如何实现总线的匹配</a></li>
</ul>
</li>
<li><a href="#4-platform">4. 平台总线(platform)的基本概念</a><ul>
<li><a href="#_1">为什么会有平台总线：</a></li>
</ul>
</li>
<li><a href="#5-platform">5. 平台总线(platform)编程接口</a></li>
<li><a href="#5-platform-led">5. 写一个platform led驱动</a></li>
</ul>
</li>
<li><a href="#iic">IIC总线驱动</a><ul>
<li><a href="#1-i2c">1 i2c协议和时序</a></li>
<li><a href="#2-i2c">2 i2c子系统软件框架 ##</a></li>
<li><a href="#3-i2c">3  I2c子系统中涉及到的设备树文件：</a></li>
<li><a href="#4-i2c-driver">4  i2c driver驱动的编写</a><ul>
<li><a href="#i2c-driver-i2cprobe6thiic_drv">编写一个最简单的i2c driver驱动，最终可实现调用 i2c的probe，代码可参考（6th/iic_drv）</a></li>
</ul>
</li>
<li><a href="#4">4 陀螺仪和加速度工作原理，它们的应用</a></li>
<li><a href="#41">4.1  硬件接线图</a></li>
<li><a href="#42">4.2  陀螺仪和加速度工作原理及应用</a><ul>
<li><a href="#421">4.2.1  陀螺仪</a></li>
</ul>
</li>
<li><a href="#5-mpu605">5 mpu605   常用寄存器</a></li>
<li><a href="#6-iicapis">6 iic驱动发送指令APIs</a></li>
<li><a href="#7-ioctl">7 ioctl:　给驱动发送不同指令</a></li>
<li><a href="#8-mpu6050">8 mpu6050的数据</a></li>
</ul>
</li>
</ul>
</div>
<hr />
<hr />
<h2 id="1">1. 总线的基本概念</h2>
<p>1.1 Linux设备驱动模型的由来</p>
<ol>
<li>实现入口函数<code>xxx_init()</code>和卸载函数<code>xxx_exit()</code></li>
<li>申请设备号 <code>register_chrdev</code> (与内核相关)</li>
<li>利用udev/mdev机制创建设备文件(节点) <code>class_create, device_create</code> (与内核相关)</li>
<li>
<p>硬件部分初始化</p>
<blockquote>
<p>io资源映射 ioremap,内核提供gpio库函数 (与硬件相关)</p>
<p>注册中断(与硬件相关) <br />
5. 构建 file_operation结构 (与内核相关)
6. 实现操作硬件方法  xxx_open,xxx_read,xxxx_write</p>
</blockquote>
</li>
</ol>
<p><img alt="" src="../images/驱动驱动模型.png" /></p>
<h2 id="2-sysfs">2. Sysfs文件系统</h2>
<p>:<img alt="" src="../images/sysfs文件系统.png" />
:<img alt="" src="images/sys目录.png" /></p>
<pre><code>block：用于管理块设备，系统中的每一个块设备会在该目录下对应一个子目录。
bus：用于管理总线，每注册一条总线，在该目录下有一个对应的子目录。
其中，每个总线子目录下会有两个子目录：devices和drivers。
devices包含系统中所有属于该总线的的设备。
class：将系统中的设备按功能分类。
dev：该目录包含已注册的设备号（设备节点)的视图，包括char和block
kernel：内核中的相关参数。
module：内核中的模块信息。
fireware：内核中的固件信息。
fs：描述内核中的文件系统。
</code></pre>
<h2 id="3">3. 写一个自己的总线驱动</h2>
<p>写一个自己的总线模型，实现如下图的功能：</p>
<p><img alt="" src="../images/总线模型编程.png" /></p>
<h3 id="31-bus">3.1 写一个自己的总线驱动——bus</h3>
<ol>
<li>
<p>数据类型</p>
<p>struct bus_type {</p>
<p>const char      *name;  //假如name =xxx cat /sys/bus/XXX</p>
<p>int (<em>match)(struct device </em>dev, struct device_driver *drv);</p>
<p>........</p>
<p>}</p>
</li>
<li>
<p>API
2.1 创建</p>
<p>int  bus_register(struct bus_type *bus);</p>
</li>
</ol>
<p>2.2 注销</p>
<pre><code>void bus_unregister(struct bus_type *bus);
</code></pre>
<h3 id="32-driver">3.2 写一个自己的总线驱动——driver</h3>
<ol>
<li>数据类型<pre><code>struct device_driver {
const char      *name;
struct bus_type     *bus;

int (*probe) (struct device *dev);
int (*remove) (struct device *dev);

};
</code></pre>
</li>
</ol>
<h3 id="33-device">3.3 写一个自己的总线驱动——device</h3>
<ol>
<li>数据类型<pre><code>struct device{

struct kobject kobj;//代表一切对象的父类，那么，在这里引了kobject，说明device是继承kobject,
const char      *init_name; /* device 的名字 */

struct bus_type *bus;       /* 需要挂接上的bus总线 mybus */
struct device_driver *driver;   /* 与之（内核做的）已经匹配成功的drv */
void        *platform_data; /* 万能型 指针 指向dev的自定义的某些数据，或者说用于drv与dev传递数据的一个载体*/
}
</code></pre>
</li>
</ol>
<p>2 APIs</p>
<p>2.1 创建</p>
<pre><code>int device_register(struct device *dev)
</code></pre>
<p>2.2 注销</p>
<pre><code>void device_unregister(struct device *dev)
</code></pre>
<h3 id="34">3.4 如何实现总线的匹配</h3>
<p>如何实现总线匹配，匹配成功之后会自动调用driver的probe方法：</p>
<blockquote>
<p>1， 实现bus对象中 match方法 </p>
<p>2， 保证driver和device中名字要一样</p>
<pre><code>//如果返回值 为1 代表匹配成功，否则不成功
int mybus_match(struct device *dev, struct device_driver *drv)
{
</code></pre>
</blockquote>
<pre><code>    printk("-------------%s------------\n",__FUNCTION__);

    if( strncmp(dev-&gt;kobj.name ,    drv-&gt;name ,  sizeof(drv-&gt;name))  ==  0   )
    {
        printk("match ok\n");
        return 1;
    }
    else 
    {
        printk("match error\n");
        return 0;
    }
}
</code></pre>
<h2 id="4-platform">4. 平台总线(platform)的基本概念</h2>
<p><img alt="" src="../images/平台总线模型.png" /></p>
<p>平台总线模型：</p>
<h5 id="_1">为什么会有平台总线：</h5>
<p>1 从厂商的角度出发</p>
<pre><code>用于平台升级：三星：　2410, 2440, 6410, s5pc100  s5pv210  4412
    硬件平台升级的时候，部分的模块的控制方式，基本上是类似的
    但是模块的地址是不一样

    gpio控制逻辑： 1， 配置gpio的输入输出功能： gpxxconf
                  2， 给gpio的数据寄存器设置高低电平： gpxxdata
                      逻辑操作基本上是一样的
                      但是地址不一样

    uart控制：1,设置8n1,115200, no AFC
                UCON,ULCON, UMODOEN, UDIV

                "逻辑基本上是一样的,但是地址不一样"

问题：
当soc升级的时候， 对于相似的设备驱动，需要编写很多次(如果不用平台总线)
但是会有大部分重复代码

解决：引入平台总线   
    device(中断/地址)和driver(操作逻辑) 分离
    在升级的时候，只需要修改device中信息即可(中断/地址)
    实现一个driver代码能够驱动多个平台相似的模块，并且修改的代码量很少
</code></pre>
<p>2 从使用者的角度出发</p>
<h2 id="5-platform">5. 平台总线(platform)编程接口</h2>
<p>平台总线中的三元素：</p>
<p>1， bus：邮bus衍生出来的platform_bus:不需要自己创建，开机的时候自动创建</p>
<pre><code>    struct bus_type platform_bus_type = {
        .name       = "platform",
        .dev_groups = platform_dev_groups,
        .match      = platform_match,
        .uevent     = platform_uevent,
        .pm     = &amp;platform_dev_pm_ops,
    };

匹配方法：

static int platform_match(struct device *dev, struct device_driver *drv)
{
    struct platform_device *pdev = to_platform_device(dev);
    struct platform_driver *pdrv = to_platform_driver(drv);

    /* Attempt an OF style match first */
    if (of_driver_match_device(dev, drv))
        return 1;

    /* Then try ACPI style match */
    if (acpi_driver_match_device(dev, drv))
        return 1;

    /* Then try to match against the id table */
    if (pdrv-&gt;id_table)
        return platform_match_id(pdrv-&gt;id_table, pdev) != NULL;

    /* fall-back to driver name match */
    return (strcmp(pdev-&gt;name, drv-&gt;name) == 0);
}

    。。。。。。dts   acpi
    1，优先匹配pdriver中的id_table,里面包含了支持不同的平台的名字
    2，直接匹配driver中名字和device中名字
</code></pre>
<p>2，device对象：</p>
<pre><code>struct platform_device {
    const char  *name;  //用于做匹配
    int     id;  // 一般都是直接给-1
    struct device   dev; // 继承了device父类
    u32     num_resources; // 资源的个数
    struct resource *resource; // 资源：包括了一个设备的地址和中断
}
</code></pre>
<p>资源对象resource:</p>
<pre><code>struct resource {
resource_size_t start;
resource_size_t end;
const char *name;
unsigned long flags;
struct resource *parent, *sibling, *child;
};
</code></pre>
<p>注册和注销</p>
<pre><code>    int  platform_device_register(struct platform_device * pdev)；
    void  platform_device_unregister(struct platform_device * pdev)
</code></pre>
<p>3，driver对象</p>
<pre><code>struct platform_driver {
        int (*probe)(struct platform_device *); //匹配成功之后被调用的函数
        int (*remove)(struct platform_device *);//device移除的时候调用的函数
        struct device_driver driver; //继承了driver父类
                            |
                            const char      *name;
        const struct platform_device_id *id_table; //如果driver支持多个平台，在列表中写出来
}
注册和注销
    int platform_driver_register(struct platform_driver *drv);
    void platform_driver_unregister(struct platform_driver *drv)
</code></pre>
<p>4， drv如何去获取dev中的数据</p>
<blockquote>
<p>获取资源数据</p>
<pre><code>int platform_get_irq(struct platform_device * dev,unsigned int num)                                     
struct resource * platform_get_resource_byname(struct platform_device * dev,
                    unsigned int type,const char * name)
</code></pre>
</blockquote>
<h2 id="5-platform-led">5. 写一个platform led驱动</h2>
<p>编写代码：　编写一个能在多个平台下使用的led驱动</p>
<p>1，注册一个platform_device,定义资源：地址和中断</p>
<pre><code>struct resource {
    resource_size_t start; // 开始
    resource_size_t end; //结束
    const char *name; //描述，自定义
    unsigned long flags; //区分当前资源描述的是中断(IORESOURCE_IRQ)还是内存（IORESOURCE_MEM）
        #define IORESOURCE_MEM      0x00000200
        #define IORESOURCE_REG      0x00000300  /* Register offsets */
        #define IORESOURCE_IRQ      0x00000400
    struct resource *parent, *sibling, *child;
};
</code></pre>
<p>2，注册一个platform_driver，实现操作设备的代码</p>
<pre><code>注册完毕，同时如果和pdev匹配成功，自动调用probe方法：
        probe方法： 对硬件进行操作
                a，注册设备号，并且注册fops--为用户提供一个设备标示，同时提供文件操作io接口
                b， 创建设备节点
                c， 初始化硬件
                            ioremap(地址);  //地址从pdev需要获取
                            readl/writle();
                d，实现各种io接口： xxx_open, xxx_read, ..
        获取资源的方式：        
        //获取资源
        // 参数1: 从哪个pdev中获取资源
        // 参数2:  资源类型
        // 参数3: 表示获取同种资源的第几个
            struct resource *platform_get_resource(struct platform_device *dev, unsigned int type, unsigned int num)
</code></pre>
<p>3，platform 获取中断（irq）资源
/<em><em>
 * platform_get_irq - get an IRQ for a device
 * @dev: platform device
 * @num: IRQ number index
 </em>/
int platform_get_irq(struct platform_device </em>dev, unsigned int num)</p>
<p>4 ，platform id_table的定义：</p>
<pre><code>struct platform_device_id {
    char name[PLATFORM_NAME_SIZE];
    kernel_ulong_t driver_data;
};
</code></pre>
<h1 id="iic">IIC总线驱动</h1>
<p>主要内容：</p>
<ol>
<li>i2c协议和时序</li>
<li>i2c子系统软件框架</li>
<li>i2c从设备驱动编写方式--不考虑具体的硬件</li>
<li>mpu6050硬件连接，陀螺仪和加速度工作原理，它们的应用</li>
<li>mpu6050数据和获取</li>
<li>mpu6050从设备驱动编写</li>
</ol>
<h2 id="1-i2c">1 i2c协议和时序</h2>
<p>IIC通讯波形图:
<img alt="" src="../images/iic协议波形.png" /></p>
<p>IIC协议:
<img alt="" src="../images/IIC读写操作.png" /></p>
<h2 id="2-i2c">2 i2c子系统软件框架 ##</h2>
<pre><code>应用
------------------------------------------
i2c driver:从设备驱动层
     需要和应用层进行交互
     封包数据，不知道数据是如何写入到硬件

------------------------------------------
i2c 核心层：维护i2c 总线，包括i2c driver, i2c client链表
drivers/i2c/i2c-core.c
---------------------------------------------------
i2c adapter层：i2c控制层，初始化i2c控制器
        完成将数据写入或读取-从设备硬件
        不知道数据具体是什么，但是知道如何操作从设备
drivers/i2c/busses/i2c-s3c2410.c
================================================================
</code></pre>
<p>去内核确定：i2c硬件驱动代码是否加入内核一起编译</p>
<pre><code>make menuconfig
    Device Drivers  ---&gt;
        -*- I2C support  ---&gt; //编译i2c-core.c
            I2C Hardware Bus support  ---&gt;
                &lt;*&gt; S3C2410 I2C Driver // i2c-s3c2410.c
</code></pre>
<h2 id="3-i2c">3  I2c子系统中涉及到的设备树文件：</h2>
<blockquote>
<p>查看原理图：MPU6050挂载至 I2C_5</p>
<p>查看6050datasheet：如果AD0是高电平的话，那么，mpu6050的地址就是0x69,否则AD0为低时候，就是0x68</p>
</blockquote>
<p>设备树：</p>
<p>控制器对应的设备树：arch/arm/boot/dts/exynos4.dtsi</p>
<pre><code>      i2c_0: i2c@13860000 {
            #address-cells = &lt;1&gt;;
            #size-cells = &lt;0&gt;;
            compatible = "samsung,s3c2440-i2c";
            reg = &lt;0x13860000 0x100&gt;;
            interrupts = &lt;0 58 0&gt;;
            clocks = &lt;&amp;clock 317&gt;;
            clock-names = "i2c";
            pinctrl-names = "default";
            pinctrl-0 = &lt;&amp;i2c0_bus&gt;;
            status = "disabled";
    };

    i2c_5: i2c@138B0000 {
            #address-cells = &lt;1&gt;;
            #size-cells = &lt;0&gt;;
            compatible = "samsung,s3c2440-i2c";
            reg = &lt;0x138B0000 0x100&gt;;
            interrupts = &lt;0 63 0&gt;;
            clocks = &lt;&amp;clock 322&gt;;
            clock-names = "i2c";
            status = "disabled";
    };
</code></pre>
<p>我们用的：   arch/arm/boot/dts/exynos4412-fs4412.dts</p>
<pre><code>    i2c@13860000 {
            #address-cells = &lt;1&gt;;
            #size-cells = &lt;0&gt;;
            samsung,i2c-sda-delay = &lt;100&gt;;
            samsung,i2c-max-bus-freq = &lt;20000&gt;;
            pinctrl-0 = &lt;&amp;i2c0_bus&gt;;
            pinctrl-names = "default";
            status = "okay";
            s5m8767_pmic@66 {
                    compatible = "samsung,s5m8767-pmic";
                    reg = &lt;0x66&gt;;
                    ...........
                    };
            };
</code></pre>
<p>我们自己做一个设备树节点，来描述mpu6050的信息：</p>
<pre><code>i2c控制器地址0-8组 共9组设备
    0x1386_0000, //0
    0x1387_0000,
    0x1388_0000, 
    0x1389_0000,
    0x138A_0000,
    0x138B_0000, ------ MPU6050
    0x138C_0000, 
    0x138D_0000, 
    0x138E_0000,//8
</code></pre>
<p>i2C_5的设备树节点：</p>
<pre><code>i2c@138B0000{
            #address-cells = &lt;1&gt;;
            #size-cells = &lt;0&gt;;
            samsung,i2c-sda-delay = &lt;100&gt;;
            samsung,i2c-max-bus-freq = &lt;20000&gt;;
            pinctrl-0 = &lt;&amp;i2c5_bus&gt;;
            pinctrl-names = "default";
            status = "okay";

            mpu6050@68 {
                    compatible = "InvenSense,mpu6050";
                    reg = &lt;0x68&gt;;
                    };

    };
</code></pre>
<p>编译设备树源码：</p>
<pre><code>make dtbs
</code></pre>
<p>烧写：。。。。。。。</p>
<h2 id="4-i2c-driver">4  i2c driver驱动的编写</h2>
<blockquote>
<p>a， 添加i2c client的信息，必须包含在控制器对应的节点中</p>
<p>b，直接编写i2c driver</p>
<p>1，构建i2c driver，并注册到i2c总线</p>
<p>2，实现probe：
      |
      申请设备号，实现fops
      创建设备文件
      通过i2c的接口去初始化i2c从设备</p>
</blockquote>
<p>几个常用的对象：</p>
<pre><code>struct i2c_driver {//表示是一个从设备的驱动对象
    int (*probe)(struct i2c_client *, const struct i2c_device_id *);
    int (*remove)(struct i2c_client *);
    struct device_driver driver; //继承了父类
                |
                const struct of_device_id   *of_match_table;
    const struct i2c_device_id *id_table;//用于做比对，非设备树的情况
}
注册和注销
    int i2c_add_driver( struct i2c_driver *driver);
    void i2c_del_driver(struct i2c_driver *);


struct i2c_client {//描述一个从设备的信息,不需要在代码中创建，因为是由i2c adapter帮我们创建
    unsigned short addr;        //从设备地址，来自于设备树中&lt;reg&gt;
    char name[I2C_NAME_SIZE]; //用于和i2c driver进行匹配，来自于设备树中compatible
    struct i2c_adapter *adapter;//指向当前从设备所存在的i2c adapter
    struct device dev;      // 继承了父类
};
创建i2c client的函数
struct i2c_client *i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)



struct i2c_adapter {//描述一个i2c控制器，也不是我们要构建，原厂的代码会帮我们构建
    const struct i2c_algorithm *algo; //算法
                |
                int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs,int num);

    struct device dev; //继承了父类，也会被加入到i2c bus
    int nr; //编号

}
注册和注销：
int i2c_add_adapter(struct i2c_adapter * adapter);
void i2c_del_adapter(struct i2c_adapter * adap);
</code></pre>
<h4 id="i2c-driver-i2cprobe6thiic_drv">编写一个最简单的i2c driver驱动，最终可实现调用 i2c的probe，代码可参考（6th/iic_drv）</h4>
<h2 id="4">4 陀螺仪和加速度工作原理，它们的应用</h2>
<h2 id="41">4.1  硬件接线图</h2>
<blockquote>
<p>查看原理图：MPU6050挂载至 I2C_5</p>
<p>查看6050datasheet：如果AD0是高电平的话，那么，mpu6050的地址就是0x69,否则AD0为低时候，就是0x68</p>
</blockquote>
<h2 id="42">4.2  陀螺仪和加速度工作原理及应用</h2>
<h3 id="421">4.2.1  陀螺仪</h3>
<p>陀螺仪的模型：</p>
<p><img alt="" src="../images/陀螺仪基本结构.png" /></p>
<p>原理：</p>
<blockquote>
<p>小时候玩过陀螺，如果给它一定的旋转速度，陀螺会竖立旋转起来而不会倒</p>
<p>主要因为高速旋转有抗拒方向改变的趋向</p>
<p>陀螺仪就是内部的转子高速旋转，形成一个固定的初始化的参考平面</p>
<p>这样就可以通过测量初始的参考平面偏差计算出物体的旋转情况</p>
<p>陀螺仪的强项在于测量设备自身的旋转运动</p>
</blockquote>
<p>陀螺仪的产生：</p>
<pre><code>1850年法国的物理学家福柯(J.Foucault)为了研究地球自转，首先发现高速转动中的转子(rotor)，
由于惯性作用它的旋转轴永远指向一固定方向，他用希腊字gyro(旋转)和skopein(看)
两字合为gyro scopei一字来命名这种仪表
</code></pre>
<p>陀螺仪的基本部件：</p>
<pre><code>(1) 陀螺转子，转子装在一支架内
(2)内、外环，它是使陀螺自转轴获得所需角转动自由度的结构
    内环可环绕平面两轴作自由运动
    在内环架外加上一外环架，可以环绕平面做三轴作自由运动
(3) 附件(是指力矩马达、信号传感器等)。
</code></pre>
<p>陀螺仪的数据获取：       </p>
<pre><code>XYZ分别代表设备围绕XYZ三个轴旋转的角速度，陀螺仪可以捕捉很微小的运动轨迹变化，
因此可以做高分辨率和快速反应的旋转检测，但不能测量当前的运行方向
</code></pre>
<p>应用：</p>
<pre><code>1，陀螺仪用于飞行体运动的自动控制系统中，作为水平、垂直、俯仰、航向和角速度传感器
2，手机上的摄像头配合使用，比如防抖
3，各类手机游戏的传感器，包括一些第一视角类射击游戏，陀螺仪完整监测游戏者手的位移
   手机中的陀螺仪最早被iphone4应用，所以被大家所熟知
4，导航，手机配合GPS，导航能力已经可以达到专用的gps导航仪
</code></pre>
<p>加速度传感器：</p>
<p>重力加速度传感器的模型：</p>
<p><img alt="" src="../images/重力传感器原理.png" /></p>
<p>原理：</p>
<pre><code>重力施加在物体上,使它产生一个加速度，重力大小和此物体的质量成正比
物体在不同的运行中，会产生不同的重力，从而可以测量出物体的运动情况
</code></pre>
<p>重力加速度的数据获取：</p>
<pre><code>加速度测量传感器有x、y、z三轴，注意在手机上屏幕的坐标，以左上角作为原点的，而且Y向下。
注意区分这两个不同的坐标系。
加速传感器的单位是加速度m/s2。如果手机平放好，x，y在位置为0，
而z轴方向加速度=当前z方向加速度-g。由于g（重力加速度）垂直向下，
则g=-9.81m/s2，即z轴 a=0-(-9.81)=9.81m/s2
</code></pre>
<p>应用：</p>
<pre><code>1，图像自动翻转
2，游戏控制
3，计步器功能
</code></pre>
<h2 id="5-mpu605">5 mpu605   常用寄存器</h2>
<pre><code>#define SMPLRT_DIV      0x19 //采样频率寄存器-25 典型值：0x07(125Hz)
                                    //寄存器集合里的数据根据采样频率更新
#define CONFIG          0x1A    //配置寄存器-26-典型值：0x06(5Hz)
                                        //DLPF is disabled（DLPF_CFG=0 or 7）
#define GYRO_CONFIG     0x1B//陀螺仪配置-27,可以配置自检和满量程范围
                                    //典型值：0x18(不自检，2000deg/s)
#define ACCEL_CONFIG        0x1C    //加速度配置-28 可以配置自检和满量程范围及高通滤波频率
                                        //典型值：0x01(不自检，2G，5Hz)
#define ACCEL_XOUT_H    0x3B //59-65,加速度计测量值 XOUT_H
#define ACCEL_XOUT_L    0x3C  // XOUT_L
#define ACCEL_YOUT_H    0x3D  //YOUT_H
#define ACCEL_YOUT_L    0x3E  //YOUT_L
#define ACCEL_ZOUT_H    0x3F  //ZOUT_H
#define ACCEL_ZOUT_L    0x40 //ZOUT_L---64
#define TEMP_OUT_H      0x41 //温度测量值--65
#define TEMP_OUT_L      0x42
#define GYRO_XOUT_H     0x43 //陀螺仪值--67，采样频率（由寄存器 25 定义）写入到这些寄存器
#define GYRO_XOUT_L     0x44
#define GYRO_YOUT_H     0x45
#define GYRO_YOUT_L     0x46
#define GYRO_ZOUT_H     0x47
#define GYRO_ZOUT_L     0x48 //陀螺仪值--72
#define PWR_MGMT_1      0x6B //电源管理 典型值：0x00(正常启用)
</code></pre>
<h2 id="6-iicapis">6 iic驱动发送指令APIs</h2>
<pre><code>//发送iic数据的API
i2c_master_send(const struct i2c_client * client, const char * buf, int count)
//接收
i2c_master_recv(const struct i2c_client * client, char * buf, int count)

传送iic消息的最小单位为struct i2c_msg msg;

struct i2c_msg {//描述一个从设备要发送的数据的数据包
    __u16 addr;  //从设备地址，发送给那个从设备
    __u16 flags; //读1还是写0
    __u16 len;  //收发数据的长度
    __u8 *buf;  //指向收发数据的指针
};
</code></pre>
<p>以上两个函数都调用了：</p>
<pre><code>int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
</code></pre>
<h2 id="7-ioctl">7 ioctl:　给驱动发送不同指令</h2>
<pre><code>应用程序：
    ioctl(fd, cmd, args);
========================================
驱动中：xxx_ioctl()
{
        switch(cmd){

        }
}

如何定义命令：
    1， 直接定义一个数字
        #define IOC_GET_ACCEL  0x9999
    2, 通过系统的接口
        _IO(x,y)
        _IOR(x,y,z)
        _IOW(x,y,z)

        参数1：表示magic，字符
        参数2：区分不同命令，整数　
        参数３：传给驱动数据类型
</code></pre>
<p>mpu605——ioctl的用法举例：</p>
<pre><code>#define IOC_GET_ACCEL  _IOR('M', 0x34,union mpu6050_data)
#define IOC_GET_GYRO  _IOR('M', 0x35,union mpu6050_data)
#define IOC_GET_TEMP  _IOR('M', 0x36,union mpu6050_data)
</code></pre>
<h2 id="8-mpu6050">8 mpu6050的数据</h2>
<pre><code>    陀螺仪可测范围为 欧拉角格式±250，±500，±1000，±2000°/秒（dps） ，加速度计可测范围为±2，±4，±8，±16g
    加速度读取的值为：
    AFS_SEL      Full scale rang                  LSB  Sensitivy
        0               +-2g -----------------------16384 LSB/g
        1               +-4g -----------------------8192 LSB/g
        2               +-8g -----------------------4096 LSB/g
        3               +-16g------------------------2048 LSB/g

    温度值：
            C = (TEMP_OUT Register Value )/340 + 36.53

    陀螺仪值：
        FS_SEL      Full scale rang                  LSB  Sensitivy
        0               +-250 度/s ------------------131 LSB 度/s
        1               +-500 度/s ------------------65.5 LSB 度/s
        2               +-1000 度/s -----------------32.8 LSB 度/s
        3               +-2000 度/s ------------------16.4 LSB 度/s
</code></pre></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js" defer></script>
        <script src="../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
